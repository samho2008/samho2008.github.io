(window.webpackJsonp=window.webpackJsonp||[]).push([[277],{2153:function(e,a,s){"use strict";s.r(a);var t=s(34),r=Object(t.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"如何理解redis中aof方式的持久化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何理解redis中aof方式的持久化"}},[e._v("#")]),e._v(" 如何理解Redis中AOF方式的持久化？")]),e._v(" "),s("p",[e._v("Redis 中 AOF 方式的持久化是将 Redis 收到的每一个写命令都追加到磁盘文件的最后，类似于 MySQL 的binlog。当 Redis 重启时，会重新执行文件中保存的写命令，然后在内存中重建整个数据库的内容。")]),e._v(" "),s("p",[e._v("AOF 持久化默认是关闭的，可以通过配置 appendonly yes 开启。当 AOF 持久化功能打开后，服务器在执行完一个写命令之后，会将被执行的写命令追加到服务器端 aof 缓冲区（aof_buf）的末尾，然后再将 aof_buf 中的内容写到磁盘。")]),e._v(" "),s("p",[e._v("Linux 操作系统中为了提升性能，使用了页缓存（page cache）。当我们将 aof_buf 的内容写到磁盘上时，此时数据并没有真正的落盘，而是存在 page cache 中，为了将 page cache 中的数据真正落盘，需要执行 fsync / fdatasync 命令来强制刷盘。这边的文件同步做的就是刷盘操作，或者叫文件刷盘可能更容易理解一些。")]),e._v(" "),s("h2",{attrs:{id:"aof持久化优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof持久化优点"}},[e._v("#")]),e._v(" AOF持久化优点")]),e._v(" "),s("p",[e._v("AOF 比 RDB 更加可靠。你可以设置不同的 fsync 策略（no、everysec 和 always）。默认是 everysec，在这种配置下，redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据。")]),e._v(" "),s("p",[e._v("AOF 文件是一个基于纯追加模式的日志文件。即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机等等）， 我们也可以使用 redis-check-aof 工具也可以轻易地修复这种问题。")]),e._v(" "),s("p",[e._v("当 AOF 文件太大时，Redis 会自动在后台进行重写。重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。整个重写是绝对安全，因为重写是在一个新的文件上进行，同时 Redis 会继续往旧的文件追加数据。当新文件重写完毕，Redis 会把新旧文件进行切换，然后开始把数据写到新文件上。")]),e._v(" "),s("p",[e._v("AOF 文件有序地保存了对数据库执行的所有写入操作，以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析也很轻松。如果你不小心执行了 FLUSHALL 命令把所有数据刷掉了，但只要 AOF 文件没有被重写，那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。")]),e._v(" "),s("h2",{attrs:{id:"aof持久化缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof持久化缺点"}},[e._v("#")]),e._v(" AOF持久化缺点")]),e._v(" "),s("p",[e._v("对于相同的数据集，AOF 文件的大小一般会比 RDB 文件大。根据所使用的 fsync 策略，AOF 的速度可能会比 RDB 慢。通常 fsync 设置为每秒一次就能获得比较高的性能，而关闭 fsync 可以让 AOF 的速度和 RDB 一样快。AOF 可能会因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。阻塞命令 BRPOPLPUSH 就曾经引起过这样的 bug 。虽然这种 bug 在 AOF 文件中并不常见， 但是相较而言， RDB 几乎是不可能出现这种 bug 的。")]),e._v(" "),s("blockquote",[s("p",[e._v("参考资料：")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://mp.weixin.qq.com/s/bxoCgB1gg-hV4IQKO_yCnA",target:"_blank",rel:"noopener noreferrer"}},[e._v("如何理解Redis中AOF方式的持久化？"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=r.exports}}]);