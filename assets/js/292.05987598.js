(window.webpackJsonp=window.webpackJsonp||[]).push([[292],{2180:function(e,v,_){"use strict";_.r(v);var o=_(34),c=Object(o.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"mvc-设计规范"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mvc-设计规范"}},[e._v("#")]),e._v(" MVC 设计规范")]),e._v(" "),_("p",[e._v("常见的 Web MVC 分为：controller、service、dao 三个层级。")]),e._v(" "),_("ul",[_("li",[e._v("controller：用于接收前端的请求和响应最终的结果给前端。在这里会对前端传入的参数进行校验，controller 层主要把前端的请求参数交给 service 层处理。")]),e._v(" "),_("li",[e._v("service：业务层，把 controller 层从前端接收到的参数进一步处理，其中业务层可能会需要调用 dao 层对数据库进一步获取数据。")]),e._v(" "),_("li",[e._v("dao：数据库层，对业务数据进行增删改查。")])]),e._v(" "),_("p",[e._v("注意：")]),e._v(" "),_("p",[e._v("controller 层禁止处理业务逻辑，业务逻辑应该放到 service 层来处理，因为 service 层的方法可能会在其他 controller 也会调用到，保证代码的复用性，可读性！所有前端的参数在 controller 层都要重新进行校验，防止绕过前端校验直接调用 API，为了简化代码，可以使用 "),_("code",[e._v("validation")]),e._v(" 进行前端传入数据的校验，这样可以避免有的数据忘记校验，也可以减少编写大量 if 判断代码。")]),e._v(" "),_("p",[e._v("service 层禁止使用 MyBatis-Plus 使用 QueryWrapper 查询数据，因为可读性太差，以及无法复用查询代码，难以调试和维护，如果要用，必须直接在 dao 层封装，然后 service 直接调用，这样可以直接用单元测试来测试 dao 层接口。")]),e._v(" "),_("p",[e._v("dao 层：禁止在方法上直接使用注解 "),_("code",[e._v("@Select")]),e._v("、"),_("code",[e._v("@Delete")]),e._v("、"),_("code",[e._v("@Update")]),e._v("、"),_("code",[e._v("@INSERT")]),e._v("，因为可读性太差，难以调试，而且一开始写的时候可能只有一行，随着业务的复杂，会导致越写越长，难以维护！")]),e._v(" "),_("h2",{attrs:{id:"坑"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#坑"}},[e._v("#")]),e._v(" 坑")]),e._v(" "),_("p",[e._v("如果后面做新的项目，所有的请求都是用 "),_("code",[e._v("POST")]),e._v(" 方式请求，不要再用 "),_("code",[e._v("GET")]),e._v(" 请求了，对于登录、提交表单这种请求用 "),_("code",[e._v("POST")]),e._v(" 很好理解，但是即使是获取数据的接口，也要用 "),_("code",[e._v("GET")]),e._v(" 请求，原因是在这个请求里会涉及到条件查询数据，那么如果使用 "),_("code",[e._v("GET")]),e._v(" 就只能采取路径参数拼接的方式，当条件过多，或者这个条件的值本身过长，就会导致无法传输的问题，换言之 "),_("code",[e._v("GET")]),e._v(" 请求在 "),_("code",[e._v("URL")]),e._v(" 中传输的数据是有限的。"),_("code",[e._v("GET")]),e._v(" 请求可以做到的，"),_("code",[e._v("POST")]),e._v(" 请求都可以做到，而且用 "),_("code",[e._v("POST")]),e._v(" 也不要用路径传参，所有数据通过请求体传输，这样还避免了一个转义的问题。而且，"),_("code",[e._v("POST")]),e._v(" 请求在后端用 "),_("code",[e._v("@RequestBody")]),e._v(" 注解标记，要用对应的一个类接收，如果后期涉及到修改请求参数，只需要修改类就可以了，上层和下层都不需要新增参数！如果添加了参数，所有调用的方法都要修改，则会涉及到很多地方，不好做兼容处理，因为对象本身可以判断是否为空，默认值就为空。")])])}),[],!1,null,null,null);v.default=c.exports}}]);